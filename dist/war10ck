#!/bin/bash

VALID_SUBCOMMANDS=(
    version
    update
    config
    install
    remove
    nuke
)

VALID_CONFIG_ARGS=(
    rundmc
    aliases
    bashrcd
    commands
    functions
    gitconfig
    history
    tmux
)

VALID_INSTALL_ARGS=(
    docker
    ghidra
    golang
    hugo
    java
    jira
    mitmproxy
    mpqeditor
    nvm
    packages
    signal
    terraform
    uv
    vscode
)

# Subcommand: version
version() {
    echo "$VERSION"
}

# Subcommand: update
update() {
    echo "[*] UPDATE..."
    if [ ! -f "/usr/local/bin/war10ck" ]; then
        echo "[!] Could not find /usr/local/bin/war10ck. Exiting."
        exit 1
    fi

    # Check latest version from GitHub tags
    echo "[*] Checking for updates..."
    local latest_version
    latest_version=$(curl -s "https://api.github.com/repos/thomaslaurenson/war10ck/tags" | grep -m 1 '"name"' | sed 's/.*"name": *"v\?\([^"]*\)".*/\1/')

    if [ -z "$latest_version" ]; then
        echo "[!] Could not determine latest version from GitHub. Exiting."
        exit 1
    fi

    if [ "$VERSION" = "v$latest_version" ]; then
        echo "[*] Already up to date."
        return
    fi

    echo "[*] Updating war10ck... requires sudo!"
    $FETCH_CMD "/tmp/war10ck" "$URL_WARLOCK"
    echo "[*] Installing to path"
    sudo mv /tmp/war10ck /usr/local/bin/war10ck
    echo "[*] Setting executable permissions"
    sudo chmod +x /usr/local/bin/war10ck
    echo "[*] Setting executable ownership"
    sudo chown root:root /usr/local/bin/war10ck
    echo "[*] Updated to version $latest_version"
}

# Subcommand: remove
remove() {
    echo "[*] REMOVE..."
    if [ -f "/usr/local/bin/war10ck" ]; then
        echo "[*] Removing war10ck... requires sudo!"
        sudo rm -f "/usr/local/bin/war10ck"
    else
        echo "[!] Could not find /usr/local/bin/war10ck. Exiting."
        exit 1
    fi
}

nuke() {
    echo "[*] Nuking configuration..."
    rm "$HOME/.war10ck/.rundmc"
    # Remove the RUNDMC block from "$HOME/.bashrc"
    # This deletes from '# RUNDMC' to the first 'fi'
    if [ -f "$HOME/.bashrc" ]; then
        sed -i '/# RUNDMC/,/fi/d' "$HOME/.bashrc"
    fi
    rm "$HOME/.war10ck/"
    echo "[*] Nuke complete."
}

# Subcommand: config
config() {
    echo "[*] CONFIG..."
    local subcommand=$1; shift
    
    # If no subcommand provided, run all config functions
    if [ -z "$subcommand" ]; then
        for arg in "${VALID_CONFIG_ARGS[@]}"; do
            "config__$arg"
        done
        return
    fi
    
    # Check if the subcommand is a valid function and call it
    if type "config__$subcommand" >/dev/null 2>&1; then
        "config__$subcommand" "$@"
    else
        echo "[!] Invalid subcommand argument: $subcommand. Exiting."
        echo "[!] Valid arguments:"
        for arg in "${VALID_CONFIG_ARGS[@]}"; do
            echo "    $arg"
        done
        exit 1
    fi
}

config__rundmc() {
    echo "[*] Configuring rundmc..."
    $FETCH_CMD "$HOME/.war10ck/.rundmc" "$URL_CONFIG_RUNDMC"

    if ! grep "# RUNDMC" "$HOME/.bashrc" > /dev/null; then
        {
            echo -e "\n# RUNDMC"
            echo -e "if [ -f $HOME/.war10ck/.rundmc ]; then"
            echo -e "    . $HOME/.war10ck/.rundmc"
            echo -e "fi"
        }  >> "$HOME/.bashrc"
    fi
}

config__aliases() {
    echo "[*] Configuring aliases..."
    $FETCH_CMD "$HOME/.war10ck/.aliases" "$URL_CONFIG_ALIASES"
}

config__bashrcd() {
    echo "[*] Configuring bashrc.d..."
    mkdir -p "$HOME/.war10ck/bashrc.d"
    chmod 700 "$HOME/.war10ck/bashrc.d"
}

config__commands() {
    echo "[*] Configuring commands..."
    $FETCH_CMD "$HOME/.war10ck/.commands" "$URL_CONFIG_COMMANDS"
}

config__functions() {
    echo "[*] Configuring functions..."
    $FETCH_CMD "$HOME/.war10ck/.functions" "$URL_CONFIG_FUNCTIONS"
}

config__gitconfig() {
    echo "[*] Configuring git..."
    $FETCH_CMD "$HOME/.gitconfig" "$URL_CONFIG_GITCONFIG"
}

config__history() {
    echo "[*] Configuring history..."
    $FETCH_CMD "$HOME/.war10ck/.history" "$URL_CONFIG_HISTORY"
}

config__tmux() {
    echo "[*] Configuring tmux..."
    $FETCH_CMD "$HOME/.war10ck/.tmux.conf" "$URL_CONFIG_TMUX_CONF"
    mkdir -p "$HOME/.war10ck/.tmux"
    $FETCH_CMD "$HOME/.war10ck/.tmux/cer" "$URL_CONFIG_TMUX_CER"
    $FETCH_CMD "$HOME/.war10ck/.tmux/home" "$URL_CONFIG_TMUX_HOME"
}

# Subcommand: install
install() {
    echo "[*] INSTALL..."
    local subcommand=$1; shift
    # Check if the subcommand is a valid function and call it
    if type "install__$subcommand" >/dev/null 2>&1; then
        "install__$subcommand" "$@"
    else
        echo "[!] Invalid subcommand argument: $subcommand. Exiting."
        echo "[!] Valid arguments:"
        for arg in "${VALID_INSTALL_ARGS[@]}"; do
            echo "    $arg"
        done
        exit 1
    fi
}

install__docker() {
    echo "[*] Installing Docker..."
    if [ -f "/usr/bin/docker" ]; then
        echo "[!] Docker already installed. Skipping installation."
    else
        $FETCH_CMD "/tmp/docker.sh" "$URL_INSTALL_DOCKER"
        sudo bash /tmp/docker.sh
        echo "[*] Docker installation complete."
        echo "[*] Please log out and back in to apply group changes."
        rm -f /tmp/docker.sh
    fi
}

install__ghidra() {
    echo "[*] Installing Ghidra..."
    $FETCH_CMD "/tmp/ghidra.sh" "$URL_INSTALL_GHIDRA"
    sudo bash /tmp/ghidra.sh
    echo "[*] Ghidra installation complete."
    rm -f /tmp/ghidra.sh
}

install__golang() {
    echo "[*] Installing Go..."
    $FETCH_CMD "/tmp/golang.sh" "$URL_INSTALL_GOLANG"
    sudo bash /tmp/golang.sh
    echo "[*] Go installation complete."
    rm -f /tmp/golang.sh
}

install__hugo() {
    echo "[*] Installing Hugo..."
    $FETCH_CMD "/tmp/hugo.sh" "$URL_INSTALL_HUGO"
    sudo bash /tmp/hugo.sh
    echo "[*] Hugo installation complete."
    rm -f /tmp/hugo.sh
}

install__java() {
    echo "[*] Installing Java..."
    $FETCH_CMD "/tmp/java.sh" "$URL_INSTALL_JAVA"
    sudo bash /tmp/java.sh
    echo "[*] Java installation complete."
    rm -f /tmp/java.sh
}

install__jira() {
    echo "[*] Installing Jira CLI..."
    $FETCH_CMD "/tmp/jira.sh" "$URL_INSTALL_JIRA"
    sudo bash /tmp/jira.sh
    echo "[*] Jira CLI installation complete."
    rm -f /tmp/jira.sh
}

install__mitmproxy() {
    echo "[*] Installing mitmproxy..."
    $FETCH_CMD "/tmp/mitmproxy.sh" "$URL_INSTALL_MITMPROXY"
    sudo bash /tmp/mitmproxy.sh
    echo "[*] mitmproxy installation complete."
    rm -f /tmp/mitmproxy.sh
}

install__mpqeditor() {
    echo "[*] Installing MPQ Editor..."
    $FETCH_CMD "/tmp/mpqeditor.sh" "$URL_INSTALL_MPQEDITOR"
    sudo bash /tmp/mpqeditor.sh
    echo "[*] MPQ Editor installation complete."
    rm -f /tmp/mpqeditor.sh
}

install__nvm() {
    echo "[*] Installing nvm..."
    $FETCH_CMD "/tmp/nvm.sh" "$URL_INSTALL_NVM"
    sudo bash /tmp/nvm.sh
    echo "[*] nvm installation complete."
    rm -f /tmp/nvm.sh
}

install__packages() {
    echo "[*] Installing packages..."
    package_list=(
        curl
        gh
        jq
        make
        python3-pip
        python3-venv
        shellcheck
        tree
        vim
        wget
    )
    sudo apt -y install "${package_list[@]}"
}

install__signal() {
    echo "[*] Installing Signal..."
    $FETCH_CMD "/tmp/signal.sh" "$URL_INSTALL_SIGNAL"
    sudo bash /tmp/signal.sh
    echo "[*] Signal installation complete."
    rm -f /tmp/signal.sh
}   

install__terraform() {
    echo "[*] Installing Terraform..."
    $FETCH_CMD "/tmp/terraform.sh" "$URL_INSTALL_TERRAFORM"
    sudo bash /tmp/terraform.sh
    echo "[*] Terraform installation complete."
    rm -f /tmp/terraform.sh
}

install__uv() {
    echo "[*] Installing UV..."
    $FETCH_CMD "/tmp/uv.sh" "$URL_INSTALL_UV"
    sudo bash /tmp/uv.sh
    echo "[*] UV installation complete."
    rm -f /tmp/uv.sh
}

install__vscode() {
    echo "[*] Installing Visual Studio Code..."
    if command -v code &> /dev/null; then
        echo "[!] Visual Studio Code already installed. Skipping installation."
    else
        $FETCH_CMD "/tmp/vscode.sh" "$URL_INSTALL_VSCODE"
        sudo bash /tmp/vscode.sh
        echo "[*] Visual Studio Code installation complete."
        rm -f /tmp/vscode.sh
    fi
}

# HELPERS

# Define backwards_cp which switches source and destination
_bcp() {
    cp "$2" "$1"
}

# Function to check if an element is in an array
_is_valid_subcommand() {
    local subcommand=$1
    for valid_subcommand in "${VALID_SUBCOMMANDS[@]}"; do
        if [[ "$valid_subcommand" == "$subcommand" ]]; then
            return 0
        fi
    done
    return 1
}

# ENTRYPOINT

# If sourced (not executed directly), register bash completion and return
if [[ "${BASH_SOURCE[0]}" != "${0}" ]]; then
    _war10ck_completions() {
        local cur prev
        COMPREPLY=()
        cur="${COMP_WORDS[COMP_CWORD]}"
        prev="${COMP_WORDS[COMP_CWORD-1]}"

        # Top-level subcommands
        if [[ $COMP_CWORD -eq 1 ]]; then
            COMPREPLY=( $(compgen -W "${VALID_SUBCOMMANDS[*]}" -- "$cur") )
            return
        fi

        # Second-level subcommands
        case "${COMP_WORDS[1]}" in
            config)
                COMPREPLY=( $(compgen -W "${VALID_CONFIG_ARGS[*]}" -- "$cur") )
                ;;
            install)
                COMPREPLY=( $(compgen -W "${VALID_INSTALL_ARGS[*]}" -- "$cur") )
                ;;
        esac
    }
    complete -F _war10ck_completions war10ck
    return
fi

VERSION=""

BASE_URL="https://war10ck.thomaslaurenson.com"

# Toggle to use local files for testing
IS_LOCAL=false
if [ "$IS_LOCAL" = true ]; then
    cd "$(dirname "$0")" || exit 1
    BASE_URL="../dist"
fi

URL_WARLOCK="$BASE_URL/war10ck"
URL_CONFIG_RUNDMC="$BASE_URL/config/rundmc"
URL_CONFIG_ALIASES="$BASE_URL/config/aliases"
URL_CONFIG_COMMANDS="$BASE_URL/config/commands"
URL_CONFIG_FUNCTIONS="$BASE_URL/config/functions"
URL_CONFIG_GITCONFIG="$BASE_URL/config/gitconfig"
URL_CONFIG_HISTORY="$BASE_URL/config/history"
URL_CONFIG_TMUX_CONF="$BASE_URL/config/tmux/tmux.conf"
URL_CONFIG_TMUX_CER="$BASE_URL/config/tmux/cer"
URL_CONFIG_TMUX_HOME="$BASE_URL/config/tmux/home"
URL_INSTALL_DOCKER="$BASE_URL/install/docker.sh"
URL_INSTALL_GHIDRA="$BASE_URL/install/ghidra.sh"
URL_INSTALL_GOLANG="$BASE_URL/install/golang.sh"
URL_INSTALL_HUGO="$BASE_URL/install/hugo.sh"
URL_INSTALL_JAVA="$BASE_URL/install/java.sh"
URL_INSTALL_JIRA="$BASE_URL/install/jira.sh"
URL_INSTALL_MITMPROXY="$BASE_URL/install/mitmproxy.sh"
URL_INSTALL_MPQEDITOR="$BASE_URL/install/mpqeditor.sh"
URL_INSTALL_NVM="$BASE_URL/install/nvm.sh"
URL_INSTALL_SIGNAL="$BASE_URL/install/signal.sh"
URL_INSTALL_TERRAFORM="$BASE_URL/install/terraform.sh"
URL_INSTALL_UV="$BASE_URL/install/uv.sh"
URL_INSTALL_VSCODE="$BASE_URL/install/vscode.sh"

# Determine fetch command to use
if [ "$IS_LOCAL" = true ]; then
    FETCH_CMD="_bcp"
elif command -v curl &> /dev/null; then
    FETCH_CMD="curl -s -o"
elif command -v wget &> /dev/null; then
    FETCH_CMD="wget -q -O"
else
    echo "[!] No fetch command found... Exiting"
    exit 1
fi

# Check a valid subcommand was passed
subcommand=$1
if ! _is_valid_subcommand "$subcommand"; then
    echo "[!] Invalid subcommand: $subcommand"
    echo "[!] Valid subcommands: ${VALID_SUBCOMMANDS[*]}"
    echo "[!] Exiting."
    exit 1
fi

# Double check a valid function name matches the subcommand
# declare -f will return 0 if the function is found (above)
# $1 is checked because this is the "subcommand" we want to run
if declare -f "$subcommand" >/dev/null 2>&1; then
    # Invoke function with all ($@) arguments
    "$@"
else
    echo "[!] Invalid subcommand: $subcommand"
    echo "[!] No matching function."
    echo "[!] Exiting."
    exit 1
fi
